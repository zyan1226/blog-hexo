<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java 函数式编程</title>
    <url>/2022/03/04/Java/JavaBase/FunctionalProgramming/</url>
    <content><![CDATA[<p>从 Java 8 开始，便拥有了函数式编程的能力。这个能力通俗来讲，就是可以把一个方法实现（也可简单的理解为代码片段）作为参数进行传递，并在适当的时候执行。</p>
<p>Java 有内置的一些类或工具就使用到这个特性，例如整理集合时所使用的<code>stream()</code></p>
<p>其实在真实的项目开发中，使用这个特性的人并不多。然而在一次偶然的开发过程中，让我深刻理解到这个特性的重要程度，以及它能为代码结构带来多大的优化空间。</p>
<h2 id="为什么要使用它？"><a href="#为什么要使用它？" class="headerlink" title="为什么要使用它？"></a>为什么要使用它？</h2><h3 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h3><p>我们来看一个代码场景，现在有一个<code>Procedure</code>类，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Procedure</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">test1</span><span class="hljs-params">(Integer t)</span> &#123;<br>        <span class="hljs-keyword">return</span> t + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">test2</span><span class="hljs-params">(Integer t)</span> &#123;<br>        <span class="hljs-keyword">return</span> t + <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">test3</span><span class="hljs-params">(Integer t)</span> &#123;<br>        <span class="hljs-keyword">return</span> t + <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>还有一个<code>Share</code>类，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Share</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> Procedure.test1(i);<br>            System.out.println(<span class="hljs-string">&quot;代码第&quot;</span> + i + <span class="hljs-string">&quot;次执行结果:&quot;</span> + value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> Procedure.test2(i);<br>            System.out.println(<span class="hljs-string">&quot;代码第&quot;</span> + i + <span class="hljs-string">&quot;次执行结果:&quot;</span> + value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">c</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> Procedure.test3(i);<br>            System.out.println(<span class="hljs-string">&quot;代码第&quot;</span> + i + <span class="hljs-string">&quot;次执行结果:&quot;</span> + value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>想想怎么优化<code>Share</code>类里的<code>a() b() c()</code>方法，提高代码的复用性，优化不允许变更<code>a() b() c()</code>方法的功能。</p>
<h3 id="一般优化"><a href="#一般优化" class="headerlink" title="一般优化"></a>一般优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Share</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> Procedure.test1(i);<br>            println(i, value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> Procedure.test2(i);<br>            println(i, value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">c</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> Procedure.test3(i);<br>            println(i, value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">println</span><span class="hljs-params">(Integer index, Integer value)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;代码第&quot;</span> + index + <span class="hljs-string">&quot;次执行结果:&quot;</span> + value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>仿佛最大的优化，也只能把打印结果的那一行代码抽出，作为公共的方法使用。</p>
<h3 id="函数式是最优解"><a href="#函数式是最优解" class="headerlink" title="函数式是最优解"></a>函数式是最优解</h3><p>通过分析可以看出，三个方法里的<code>for</code>循环是一模一样的，唯一的不同点就是这三个方法都有自己的调用逻辑：<code>a()</code>调用<code>Procedure.test1(Integer)</code>，<code>b()</code>调用<code>Procedure.test2(Integer)</code>，<code>c()</code>调用<code>Procedure.test3(Integer)</code>。</p>
<p>那么我们就可以把这个调用逻辑作为一个方法的实现内容进行传递，交给<code>println()</code>方法，让其在适当的地方调用。</p>
<p>这个时候，函数式编程就像魔法一样，把这个类的代码结构优化到淋漓尽致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Share</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//简写</span><br>        println(Procedure::test1);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//简写</span><br>        println(Procedure::test2);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">c</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//为了讲解，此处使用完整写法</span><br>        println((t)-&gt;&#123;<br>            <span class="hljs-keyword">return</span> Procedure.test3(t);<br>        &#125;);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">println</span><span class="hljs-params">(Function&lt;Integer, Integer&gt; func)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> func.apply(i);<br>            System.out.println(<span class="hljs-string">&quot;代码第&quot;</span> + i + <span class="hljs-string">&quot;次执行结果:&quot;</span> + value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        a();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Java-内置的函数式接口"><a href="#Java-内置的函数式接口" class="headerlink" title="Java 内置的函数式接口"></a>Java 内置的函数式接口</h2><p>Java 是一种强类型语言，所以在函数式编程这一特性也不例外，它不能像 JS 那样可以将任何形式（这里指参数、返回值）的函数进行传递，而是必须在函数接受方显式的规定该函数的数据类型等细节。</p>
<p>Java 利用泛型内置了一些可以灵活使用的函数式接口，你可以通过指定这些接口的泛型达到定制化的目的，来满足一般的开发需求。</p>
<h3 id="接口名称关键字整理"><a href="#接口名称关键字整理" class="headerlink" title="接口名称关键字整理"></a>接口名称关键字整理</h3><p>由于内置的函数式接口较多，这里就不再一一列举，可以<a href="https://www.runoob.com/java/java8-functional-interfaces.html">点击访问菜鸟教程网站</a>进行查阅</p>
<p>不过我发现这些接口的名称和他们的场景用途存在一定的规律，特地整理一份关键字的对照表。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>返回值</th>
<th>参数</th>
<th>执行</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer</td>
<td>无返回结果</td>
<td>有参数</td>
<td>accept方法</td>
</tr>
<tr>
<td>Supplier</td>
<td>有返回结果</td>
<td>无参数</td>
<td>get方法</td>
</tr>
<tr>
<td>Function</td>
<td>有返回结果</td>
<td>有参数</td>
<td>apply方法</td>
</tr>
<tr>
<td>Predicate</td>
<td>有返回结果，且结果为布尔值</td>
<td>有参数</td>
<td>test方法</td>
</tr>
<tr>
<td>Operator</td>
<td>有返回结果，且参数和返回结果数据类型相同</td>
<td>有参数，且参数和返回结果数据类型相同</td>
<td>apply方法</td>
</tr>
</tbody></table>
<h2 id="如何自定义函数式接口"><a href="#如何自定义函数式接口" class="headerlink" title="如何自定义函数式接口"></a>如何自定义函数式接口</h2><p>当 Java 内置的函数式接口不能满足开发需求时（例如接口的参数数量很多），你可以自己定义一个函数式接口来使用。</p>
<p>当然，出于个人喜好、项目管理等原因，你也可以在项目中完全使用自定义的函数式接口，放弃所有的内置函数式接口。</p>
<p>下面就是一个标准的函数式接口，看起来与普通的接口定义没有什么不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zyan.test;<br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestInterFace</span> &#123;<br><br>    Integer <span class="hljs-title function_">test</span><span class="hljs-params">(String a, String b, String c, String d)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此处需要注意的是，经过实践，<code>@FunctionalInterface</code>注解并不是必须的，出于习惯的原因，我都会加上该注解。</p>
<p><strong>自定义函数式接口需要满足：有且只有一个未实现的方法。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 Spring 配置文件警告</title>
    <url>/2022/03/10/Spring/correlation/SolveYmalWarn/</url>
    <content><![CDATA[<p>Spring 项目默认是使用<code>.properties</code>文件作为配置文件的，但是我们习惯上会更多的使用<code>.yml</code>文件，因为其可以体现出配置项的树形结构，可读性较强。</p>
<h2 id="配置文件乱象"><a href="#配置文件乱象" class="headerlink" title="配置文件乱象"></a>配置文件乱象</h2><p>一般在配置数据源、端口号、服务名称这些配置时并不会出现黄色警告，但是一些自定义的配置项则会出现<code>一片黄色的骇人景象</code>。</p>
<p><img    class="lazyload" data-original="https://s2.loli.net/2022/04/26/HF7eK4CEIAsTL5y.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">正常的项目配置</span></p>
<p><img    class="lazyload" data-original="https://s2.loli.net/2022/04/26/5Mxg2oscKYwlab8.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">自定义的配置项</span></p>
<p>虽然有警告，但是这并不是致命错误，因为你仍然可以正常的使用 <code>@Value(&quot;$&#123;test.a&#125;&quot;)</code> 来取值，但是作为有代码洁癖的人，这不能忍！而且 <code>@Value</code> 这种方式很容易因大意导致名称不一致，进而引起无法取值。</p>
<h2 id="主角登场"><a href="#主角登场" class="headerlink" title="主角登场"></a>主角登场</h2><p>我们先去没有警告的配置项 <code>spring.datasource.url</code> 代码内部，看看是怎么写的，能不能找点蛛丝马迹。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(</span><br><span class="hljs-meta">    prefix = &quot;spring.datasource&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceProperties</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanClassLoaderAware</span>, InitializingBean &#123;<br>    <span class="hljs-keyword">private</span> ClassLoader classLoader;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">generateUniqueName</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DataSource</span>&gt; type;<br>    <span class="hljs-keyword">private</span> String driverClassName;<br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> String jndiName;<br>    <span class="hljs-comment">//省略后部代码........</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>英语稍懂一些就会立刻注意到 <code>@ConfigurationProperties</code> 这个注解，因为它与我们此次要解决的问题非常相近，翻译过来就是 <code>配置属性</code>。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>没错，<code>@ConfigurationProperties</code> 注解就是解决配置文件警告的关键，那么他是如何使用的？</p>
<h3 id="关系映射实体类"><a href="#关系映射实体类" class="headerlink" title="关系映射实体类"></a>关系映射实体类</h3><p>像使用 <code>MyBatisPlus</code> 那样，我们需要先创建一个 <code>关系映射实体类</code>，目的是告诉 Spring，服务启动时你把哪些配置项的值给我塞到这个实体类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zyan.test.pojo.properties;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.NestedConfigurationProperty;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestProperties</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String aProperty;<br><br>    <span class="hljs-keyword">private</span> String b;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">enable</span> <span class="hljs-operator">=</span> Boolean.FALSE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要注意这个实体类必须包含 <code>Setter</code> 和 <code>Getter</code> 方法，否则你将取不到值和无法取值。并且这个类必须使用 <code>@Component</code> 注解交由 Spring 管理，或者在服务启动类上使用 <code>@ConfigurationPropertiesScan</code> 注解进行扫描。</p>
<p><code>@ConfigurationProperties</code> 注解的 <code>prefix</code> 用于指定配置项前缀，可以使用 <code>.</code> 进行多级指定。不能使用驼峰命名，只能使用 <code>-</code> 进行分词。</p>
<p>可以直接在此类中为属性赋上默认值。</p>
<h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TestProperties testProperties;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>         System.out.println(<span class="hljs-string">&quot;配置项 test.enable 取值:&quot;</span> + testProperties.getEnable());<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>将 <code>TestProperties</code> 注入到适当的位置，通过 <code>Getter</code> 方法进行取值。此处使用 <code>@RequiredArgsConstructor</code> 进行构造器注入，想要详细了解使用方法，可阅读 <a href="/2020/10/30/Spring/base/RequiredArgsConstructor/">如何优雅的进行 Bean 注入</a>。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">test:</span><br>  <span class="hljs-attr">a-property:</span> <span class="hljs-string">xxx</span><br>  <span class="hljs-attr">b:</span> <span class="hljs-string">xxx</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<p>按照习惯，建议在 <code>.yml</code> 文件中使用 <code>-</code> 进行分词，在实体类中使用驼峰命名，不要担心这样无法取值，<code>Spring</code> 会帮你进行转化，当然，你也可以选择不这么做。</p>
<h2 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h2><h3 id="多级配置"><a href="#多级配置" class="headerlink" title="多级配置"></a>多级配置</h3><p>多级配置只需要引入静态内部类即可</p>
<h4 id="映射类写法"><a href="#映射类写法" class="headerlink" title="映射类写法"></a>映射类写法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestProperties</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Other other;<br><br>    <span class="hljs-meta">@Data</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Other</span> &#123;<br>        <span class="hljs-keyword">private</span> String a;<br>        <span class="hljs-keyword">private</span> String b;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="yml-文件写法"><a href="#yml-文件写法" class="headerlink" title="yml 文件写法"></a>yml 文件写法</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">test:</span><br>  <span class="hljs-attr">other:</span><br>    <span class="hljs-attr">a:</span> <span class="hljs-string">xxx</span><br>    <span class="hljs-attr">b:</span> <span class="hljs-string">xxx</span><br></code></pre></td></tr></table></figure>

<h3 id="列表配置"><a href="#列表配置" class="headerlink" title="列表配置"></a>列表配置</h3><h4 id="映射类写法-1"><a href="#映射类写法-1" class="headerlink" title="映射类写法"></a>映射类写法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestProperties</span> &#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;Other&gt; otherList;<br><br>    <span class="hljs-meta">@Data</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Other</span> &#123;<br>        <span class="hljs-keyword">private</span> String a;<br>        <span class="hljs-keyword">private</span> String b;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="yml-文件写法-1"><a href="#yml-文件写法-1" class="headerlink" title="yml 文件写法"></a>yml 文件写法</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">test:</span><br>  <span class="hljs-attr">other-list:</span><br>    <span class="hljs-bullet">-</span><br>      <span class="hljs-attr">a:</span> <span class="hljs-string">xxx</span><br>      <span class="hljs-attr">b:</span> <span class="hljs-string">xxx</span><br>    <span class="hljs-bullet">-</span><br>      <span class="hljs-attr">a:</span> <span class="hljs-string">xxx</span><br>      <span class="hljs-attr">b:</span> <span class="hljs-string">xxx</span><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring 相关</tag>
      </tags>
  </entry>
  <entry>
    <title>如何优雅的进行 Bean 注入</title>
    <url>/2020/10/30/Spring/base/RequiredArgsConstructor/</url>
    <content><![CDATA[<p>不知道为什么，最近听到许多反对使用<code>Lombok</code>的声音，说什么影响代码可读性，具有侵入性。（弱弱的问一句，<code>Entity</code>要什么可读性？）这是我从上学的时候认识<code>Lombok</code>以来，第一次听到这样的声音。</p>
<span id="more"></span>

<p>在我看来，<code>Lombok</code>大大提高了开发效率。举个栗子，在我最近工作所开发的ERP系统中，由于行业的特殊性，一张表动辄七八十个字段，难道你会为<code>Entity</code>一个一个的去写<code>set</code>和<code>get</code>方法？或者说使用一些工具去生成？反正我打死都不会干的，毕竟人类只有越来越“懒”，才会想尽一切办法去提高生产力。</p>
<p>这篇文章暂且不谈<code>Lombok</code>的优劣，最近我在爬帖子时发现了一个注解，可以优雅的在 <code>Spring</code> 项目中进行 <code>Bean</code> 注入：<code>@RequiredArgsConstructor</code>，这个注解则由<code>Lombok</code>提供。从这个单词来理解，大致就是，<code>必须的参数构造器</code>，那么这个注解又是怎么和<code>Bean</code>注入扯上关系的？向下看。</p>
<h2 id="Bean注入乱象"><a href="#Bean注入乱象" class="headerlink" title="Bean注入乱象"></a>Bean注入乱象</h2><p><code>Spring</code>提供了三种注入模式，一种是<code>属性注入</code>(Filed injection)，一种是通过<code>setter</code>方法，一种是<code>构造器注入</code>。就目前情况来看，许多的项目看起来应该是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ARepo aRepo;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> BRepo bRepo;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> CRepo cRepo;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DRepo dRepo;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ERepo eRepo;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样的使用方法本身没有什么问题，看起来还蛮整洁哈，可真实项目里却是这样的：</p>
<p><img    class="lazyload" data-original="https://i.loli.net/2020/10/30/prTUYI6gBobwP9F.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">真实项目截图</span></p>
<p><code>Spring</code>从4.0开始，<strong>就 不 推 荐 使 用 属 性 注 入 模 式 了，</strong>原因是它可以让我们忽略掉一些代码可能变坏的隐患，同时这样的写法也使<code>IDEA</code>向你发出<code>黄色警告</code>!</p>
<p>既然<code>Spring</code>推荐使用显式的<code>Setter</code>和<code>构造器方式</code>，那我们就切换一下实现方案。</p>
<h2 id="这个样子很优雅"><a href="#这个样子很优雅" class="headerlink" title="这个样子很优雅"></a>这个样子很优雅</h2><p><code>Setter</code>方式显然不可能，我可不想把<code>Setter</code>代码生成工具玩到吐，那么就剩下了<code>构造器方式</code>，就像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ARepo aRepo;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserServiceImpl</span> <span class="hljs-params">(ARepo aRepo)</span> &#123;<br>        <span class="hljs-built_in">this</span>.aRepo = aRepo;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>或者……像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ARepo aRepo;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BRepo bRepo;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CRepo cRepo;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DRepo dRepo;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ERepo eRepo;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserServiceImpl</span> <span class="hljs-params">(ARepo aRepo,BRepo bRepo,CRepo cRepo</span><br><span class="hljs-params">                            ,DRepo dRepo,ERepo eRepo)</span> &#123;<br>        <span class="hljs-built_in">this</span>.aRepo = aRepo;<br>        <span class="hljs-built_in">this</span>.bRepo = bRepo;<br>        <span class="hljs-built_in">this</span>.cRepo = cRepo;<br>        <span class="hljs-built_in">this</span>.dRepo = dRepo;<br>        <span class="hljs-built_in">this</span>.eRepo = eRepo;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>emmm，要是这样的话，我宁愿用<code>@Autowired</code>。</p>
<p>当注入的<code>Bean</code>变多之后，构造器便显得超级臃肿，这个时候<code>@RequiredArgsConstructor</code>就派上了大用场，来看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <br>    <span class="hljs-keyword">final</span> ARepo aRepo;<br>    <span class="hljs-keyword">final</span> BRepo bRepo;<br>    <span class="hljs-keyword">final</span> CRepo cRepo;<br>    <span class="hljs-keyword">final</span> DRepo dRepo;<br>    <span class="hljs-keyword">final</span> ERepo eRepo;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>嗯，这才是我们想要的样子，相信聪明的你已经明白了<code>@RequiredArgsConstructor</code>会在编译时帮你生成那个又臭又长的构造器，达到了<code>Bean</code>注入的目的。</p>
<p>好了，如此优雅的注入，还不快拿去享用。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>学会使用 BigDecimal</title>
    <url>/2020/07/15/Java/JavaBase/BigDecimal/</url>
    <content><![CDATA[<p><code>BigDecimal</code> 是 Java 提供的一个关于小数精确计算的类，其位于<code>java.math</code>包下。</p>
<p>不同于基本数据类型，<code>BigDecimal</code>是调用相关方法来进行运算。因为其拥有非常精确的小数计算能力，所以比较适合用于财务相关的计算等等。但是，其运行效率是不及 <code>Float</code> 与 <code>Double</code> 的，要按照实际情况，运用在合理的地方。</p>
<span id="more"></span>

<h2 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;99.6&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//不建议使用</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">99.6</span>);<br></code></pre></td></tr></table></figure>

<p>强烈建议使用 String 类型进行初始化对象，强烈不推荐使用 Double 类型。原因何在？我们来看一个小测试。</p>
<p>执行下方代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">BigDecimal bigDecimal=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;99.6&quot;</span>);<br>System.out.println(bigDecimal.toString());<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">99.6<br></code></pre></td></tr></table></figure>

<p>而执行下方代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">BigDecimal bigDecimal=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">99.6</span>);<br>System.out.println(bigDecimal.toString());<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">99.599999999999994315658113919198513031005859375<br></code></pre></td></tr></table></figure>

<p>问题立刻显现出来，使用 Double 型数据初始化 Bigdecimal 是不精确的，会损失精度。这不是 BigDecimal 的问题，而属于 Double 本身。在 IDEA 中，使用 Double 初始化时，则会“报黄”警告。<mark style="background-color:pink;">所以请务必使用 String 初始化 BigDecimal !</mark></p>
<p><img    class="lazyload" data-original="https://i.loli.net/2020/07/15/iGtUM7VnseTyJSc.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">IDEA 警告</span></p>
<h2 id="建议的数据库解决方案"><a href="#建议的数据库解决方案" class="headerlink" title="建议的数据库解决方案"></a>建议的数据库解决方案</h2><p>基于上一部分得到的结论，建议在数据库中使用<code> VARCHAR</code> 类型或者 <code>DECIMAL</code>，这里以 MySQL + MyBatis 为例。</p>
<table>
<thead>
<tr>
<th>数据库数据类型</th>
<th>MyBatis 实体类数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>VARCHAR</td>
<td>String</td>
</tr>
<tr>
<td>DECIMAL</td>
<td>BigDecimal</td>
</tr>
</tbody></table>
<h2 id="加减运算"><a href="#加减运算" class="headerlink" title="加减运算"></a>加减运算</h2><blockquote>
<p>加减运算比较简单，使用 <code>add()</code> 与 <code>subtract()</code> 方法进行处理。</p>
</blockquote>
<h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;99.6&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">subtract</span> <span class="hljs-operator">=</span> bigDecimal.subtract(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;66.9&quot;</span>));<br>System.out.println(subtract.toString());<br>System.out.println(bigDecimal.toString());<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">32.7<br>99.6<br></code></pre></td></tr></table></figure>

<p>此处需要注意的是，<mark style="background-color:pink;">所有的运算方法在执行后并不会影响参与计算的数，他只会将计算结果返回！</mark></p>
<p>你可以使用新的对象来接受，或者覆盖旧的对象。</p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;99.6&quot;</span>);<br>bigDecimal = bigDecimal.subtract(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;66.9&quot;</span>));<br>System.out.println(bigDecimal.toString());<br></code></pre></td></tr></table></figure>

<h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;99.6&quot;</span>);<br>bigDecimal = bigDecimal.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;66.9&quot;</span>));<br>System.out.println(bigDecimal.toString());<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">166.5<br></code></pre></td></tr></table></figure>


<h2 id="乘除运算"><a href="#乘除运算" class="headerlink" title="乘除运算"></a>乘除运算</h2><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>使用 <code>multiply()</code>方法进行处理。</p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;99.6&quot;</span>);<br>bigDecimal = bigDecimal.multiply(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;66.9&quot;</span>));<br>System.out.println(bigDecimal.toString());<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">6663.24<br></code></pre></td></tr></table></figure>

<h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><blockquote>
<p>除法是比较特殊的一个运算，因为除数与被除数的关系，可能会造成结果为<code>无限循环小数</code>或<code>无限不循环小数</code>，为了解决这一问题你需要指定<code>小数保留方案</code>。</p>
</blockquote>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;99.6&quot;</span>);<br>bigDecimal = bigDecimal.divide(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;3&quot;</span>));<br>System.out.println(bigDecimal.toString());<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">33.2<br></code></pre></td></tr></table></figure>

<p>因为该运算结果不是<code>无限循环小数</code>，所以一切看起来都很 Nice ，但是当你稍稍改动一下，它就会“原形毕露”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;99.6&quot;</span>);<br>bigDecimal = bigDecimal.divide(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;66.9&quot;</span>));<br>System.out.println(bigDecimal.toString());<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<p style="color:red;">
    Exception in thread "main" java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.
    at java.math.BigDecimal.divide(BigDecimal.java:1690)
    at ...
<p>

<p>我是谁？我在哪？我写的是什么BUG？我们来看关键字<code>Non-terminating decimal expansion</code>，翻译过来就是<code>无穷小数扩张</code>。看到这里，你是否已经明白问题所在。也就是上边所提到的，需要指定<code>小数保留方案</code>。</p>
<p>改动一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;99.6&quot;</span>);<br>bigDecimal = bigDecimal.divide(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;66.9&quot;</span>),<span class="hljs-number">2</span>,BigDecimal.ROUND_DOWN);<br>System.out.println(bigDecimal.toString());<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1.48<br></code></pre></td></tr></table></figure>

<p>此时一切都已恢复往日的平静，那么到底是什么力量遏制住了可恶的 Exception 呢？细心的同学会发现在 <code>divide()</code>方法中多了两个参数，一个是<code>2</code>，一个是<code>BigDecimal.ROUND_DOWN</code>。其中，2是保留小数的位数，这个很容易理解。而<code>BigDecimal.ROUND_DOWN</code>又是什么东西呢？他是 BigDecimal 类中的小数保留方案常量，算上这一个，一共有八个方案常量，请看解析。</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BigDecimal.ROUND_UP</td>
<td>舍入远离零的舍入模式。在丢弃非零部分之前始终增加数字(始终对非零舍弃部分前面的数字加1)。</td>
</tr>
<tr>
<td>BigDecimal.ROUND_DOWN</td>
<td>接近零的舍入模式。在丢弃某部分之前始终不增加数字(从不对舍弃部分前面的数字加1，即截短)。</td>
</tr>
<tr>
<td>BigDecimal.ROUND_CEILING</td>
<td>接近正无穷大的舍入模式。如果 BigDecimal 为正，则舍入行为与 ROUND_UP 相同；如果为负，则舍入行为与 ROUND_DOWN 相同。</td>
</tr>
<tr>
<td>BigDecimal.ROUND_FLOOR</td>
<td>接近负无穷大的舍入模式。如果 BigDecimal 为正，则舍入行为与 ROUND_DOWN 相同；如果为负，则舍入行为与 ROUND_UP 相同。</td>
</tr>
<tr>
<td>BigDecimal.ROUND_HALF_UP</td>
<td>向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式。如果舍弃部分 &gt;&#x3D; 0.5，则舍入行为与 ROUND_UP 相同;否则舍入行为与 ROUND_DOWN 相同。注意，这是我们大多数人在小学时就学过的舍入模式(四舍五入)。</td>
</tr>
<tr>
<td>BigDecimal.ROUND_HALF_DOWN</td>
<td>向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为上舍入的舍入模式。如果舍弃部分 &gt; 0.5，则舍入行为与 ROUND_UP 相同;否则舍入行为与 ROUND_DOWN 相同(五舍六入)。</td>
</tr>
<tr>
<td>BigDecimal.ROUND_HALF_EVE</td>
<td>向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。如果舍弃部分左边的数字为奇数，则舍入行为与 ROUND_HALF_UP 相同；如果为偶数，则舍入行为与 ROUND_HALF_DOWN 相同。此舍入模式也称为“银行家舍入法”，主要在美国使用。</td>
</tr>
<tr>
<td>BigDecimal.ROUND_UNNECESSARY</td>
<td>断言请求的操作具有精确的结果，因此不需要舍入。如果对获得精确结果的操作指定此舍入模式，则抛出ArithmeticException。</td>
</tr>
</tbody></table>
<p>这么多的小数保留方案，其实常用的也不多，感兴趣的话，可以自己写个测试类玩玩。</p>
<h2 id="比较大小"><a href="#比较大小" class="headerlink" title="比较大小"></a>比较大小</h2><blockquote>
<p>比较大小也是需要调用方法的，使用<code>compareTo()</code>方法即可处理。</p>
</blockquote>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;99.6&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;66.9&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a.compareTo(b);<br>System.out.println(i);<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1<br></code></pre></td></tr></table></figure>

<p><code>compareTo()</code>方法的返回值是一个<code>int</code>型的数据，以上方示例为例，请看解析</p>
<table>
<thead>
<tr>
<th>情况</th>
<th>compareTo() 的返回值</th>
</tr>
</thead>
<tbody><tr>
<td>a&gt;b</td>
<td>1</td>
</tr>
<tr>
<td>a&#x3D;b</td>
<td>0</td>
</tr>
<tr>
<td>a&lt;b</td>
<td>-1</td>
</tr>
</tbody></table>
<p>当你要判断一个数的与0的关系（正负）时可以这样写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-99.6&quot;</span>);<br><span class="hljs-keyword">if</span> (a.compareTo(BigDecimal.ZERO) &gt; <span class="hljs-number">0</span>) &#123;<br>	<span class="hljs-comment">//a是正数</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.compareTo(BigDecimal.ZERO) == <span class="hljs-number">0</span>)&#123;<br>	<span class="hljs-comment">//a==0</span><br>&#125;<span class="hljs-keyword">else</span> &#123;<br>	<span class="hljs-comment">//a是负数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="去除无用的零"><a href="#去除无用的零" class="headerlink" title="去除无用的零"></a>去除无用的零</h3><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;99.12300000&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a.stripTrailingZeros();<br>System.out.println(b.toString());<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">99.123<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
</search>
