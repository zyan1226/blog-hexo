<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据结构之数组</title>
    <url>/2022/08/21/Algorithm/DataStructure/Array/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><blockquote>
<p>数组是一种数据结构，是有限个相同类型的变量所组成的有序集合，数组中的每一个变量被称为元素。</p>
</blockquote>
<p>以整型数组为例，数组的存储形式如下图所示：</p>
<table>
<thead>
<tr>
<th>数据</th>
<th>2</th>
<th>3</th>
<th>6</th>
<th>1</th>
<th>4</th>
<th>0</th>
<th>6</th>
<th>8</th>
<th>2</th>
</tr>
</thead>
<tbody><tr>
<td>下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
</tbody></table>
<p>如你所见，数组的每一个元素都存在一个相应的“编号”，就是<strong>下标。下标从0开始，一直到数组的长度-1。</strong></p>
<p>数组在内存中是<strong>顺序存储的</strong>，而内存是由一个个连续的<strong>内存单元</strong>组成，每一个内存单元都有自己的地址。数组中的每一元素都存储在内存单元中，而且元素之间紧密排列，既不能打乱元素的存储顺序，也不能跳过某个存储单元进行存储。</p>
<p><img    class="lazyload" data-original="https://s2.loli.net/2022/08/21/SiIxbFyO72vRsDz.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">数组存储示意图</span></p>
<p>在上图中，巧克力黄色的格子代表空闲的存储单元，灰色的格子代表已占用的存储单元，而淡绿色的连续格子代表数组在内存中的位置。</p>
<h1 id="读取元素"><a href="#读取元素" class="headerlink" title="读取元素"></a>读取元素</h1><p>读取元素是数组最简单的操作，由于数组在内存中顺序存储，所以只要给出一个数组下标，就可以读取到对应的数组元素。</p>
<p>假设有一个名为<code>array</code>的数组，想要读取数组下标为4的元素，就写作<code>array[4]</code>。</p>
<p>值得注意的是，输入的下标必须在数组的长度范围之内，否则会出现数组越界！如果数组的长度为x，输入的下标为y，那么结合下标从0开始的特点，就可以得出<strong>y<sub>max</sub>&#x3D;x-1</strong>。</p>
<p>简单的代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>&#125;;<br><span class="hljs-comment">//打印数组中下标为4的元素</span><br>System.out.println(array[<span class="hljs-number">4</span>]);<br></code></pre></td></tr></table></figure>

<h1 id="更新元素"><a href="#更新元素" class="headerlink" title="更新元素"></a>更新元素</h1><p>更新元素也是非常简单的操作，直接利用下标就可以把新值赋给该元素。</p>
<p>简单的代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>&#125;;<br><span class="hljs-comment">//为数组下标为2的元素赋上新值</span><br>array[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//打印数组中下标为2的元素</span><br>System.out.println(array[<span class="hljs-number">2</span>]);<br></code></pre></td></tr></table></figure>

<h1 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h1><h2 id="尾部插入"><a href="#尾部插入" class="headerlink" title="尾部插入"></a>尾部插入</h2><p>尾部插入是最简单的情况，直接把要插入的元素放在数组尾部的空闲位置即可，等同于更新元素的操作。</p>
<h2 id="中间插入"><a href="#中间插入" class="headerlink" title="中间插入"></a>中间插入</h2><p>中间插入稍微复杂一些，那是因为数组的每一个元素都有其固定的下标，所以不得不首先把插入位置以及后面的元素向后移动，腾出地方，再把要插入的元素放到对应的数组位置上。</p>
<p><img    class="lazyload" data-original="https://s2.loli.net/2023/01/15/ENXvWGeO3aFkArS.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">中间插入</span></p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] array;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实际元素的数量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * MyArray 构造方法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> capacity 初始容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyArray</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[capacity];<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 插入元素</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index   下标</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> element 元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> element)</span> &#123;<br>        <span class="hljs-comment">//判断下标是否超出范围</span><br>        <span class="hljs-comment">//此处判断的 index &gt; size 并非数组越界，而是必须连续插入，例如实际有5个元素，插入下标为6的数据是不被允许的</span><br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;超出数组实际元素范围！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//从右向左循环，将元素逐个向右挪1位</span><br>        <span class="hljs-comment">//尾部插入时，该循环不会执行，因为尾部执行时 size - 1 &gt;= index 永不成立</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt;= index; i--) &#123;<br>            array[i + <span class="hljs-number">1</span>] = array[i];<br>        &#125;<br>        <span class="hljs-comment">//腾出的位置放置新元素</span><br>        array[index] = element;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 输出打印</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">output</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            System.out.println(array[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyArray</span> <span class="hljs-variable">myArray</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArray</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">//尾部插入</span><br>        myArray.insert(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>        myArray.insert(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>);<br>        myArray.insert(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>);<br>        myArray.insert(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>        <span class="hljs-comment">//中间插入</span><br>        myArray.insert(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//输出打印</span><br>        myArray.output();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="超范围插入"><a href="#超范围插入" class="headerlink" title="超范围插入"></a>超范围插入</h2><p>如果数组不断插入新的元素，元素数量超过了数组的最大长度，数组就会被“撑爆”，这个就是接下来要研究的情况 —— 超范围插入。</p>
<p>假如现在有一个长度为10的数组，已经装满了元素，这时还想插入一个新元素，就必须对数组进行<strong>扩容</strong>操作。关键在于数组的长度在创建时就已确定，而且不能随意的变长或者变短，这该如何是好？</p>
<p>此时可以创建一个新的数组，长度是旧数组的2倍（此处的2倍并不代表Java的扩容机制为2倍，仅为举例说明！），再把旧数组的所有元素全部复制到新数组，这样就实现了数组的扩容。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] array;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实际元素的数量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * MyArray 构造方法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> capacity 初始容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyArray</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[capacity];<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 插入元素</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index   下标</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> element 元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> element)</span> &#123;<br>        <span class="hljs-comment">//判断下标是否超出范围</span><br>        <span class="hljs-comment">//此处判断的 index &gt; size 并非数组越界，而是必须连续插入，例如实际有5个元素，插入下标为6的数据是不被允许的</span><br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;超出数组实际元素范围！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//如果实际元素数量达到数组长度上限，则对数组进行扩容</span><br>        <span class="hljs-keyword">if</span> (size &gt;= array.length) &#123;<br>            <span class="hljs-built_in">this</span>.resize();<br>        &#125;<br><br>        <span class="hljs-comment">//从右向左循环，将元素逐个向右挪1位</span><br>        <span class="hljs-comment">//尾部插入时，该循环不会执行，因为尾部执行时 size - 1 &gt;= index 永不成立</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt;= index; i--) &#123;<br>            array[i + <span class="hljs-number">1</span>] = array[i];<br>        &#125;<br>        <span class="hljs-comment">//腾出的位置放置新元素</span><br>        array[index] = element;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 数组扩容</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//创建新数组</span><br>        <span class="hljs-type">int</span>[] newArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[array.length * <span class="hljs-number">2</span>];<br>        <span class="hljs-comment">//复制数组</span><br>        System.arraycopy(array, <span class="hljs-number">0</span>, newArray, <span class="hljs-number">0</span>, array.length);<br>        array = newArray;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 输出打印</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">output</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            System.out.println(array[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyArray</span> <span class="hljs-variable">myArray</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArray</span>(<span class="hljs-number">4</span>);<br>        <span class="hljs-comment">//尾部插入</span><br>        myArray.insert(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>        myArray.insert(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>);<br>        myArray.insert(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>);<br>        myArray.insert(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>        <span class="hljs-comment">//中间插入</span><br>        myArray.insert(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//输出打印</span><br>        myArray.output();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 Spring 配置文件警告</title>
    <url>/2022/03/10/Spring/correlation/SolveYmalWarn/</url>
    <content><![CDATA[<p>Spring 项目默认是使用<code>.properties</code>文件作为配置文件的，但是我们习惯上会更多的使用<code>.yml</code>文件，因为其可以体现出配置项的树形结构，可读性较强。</p>
<h1 id="配置文件乱象"><a href="#配置文件乱象" class="headerlink" title="配置文件乱象"></a>配置文件乱象</h1><p>一般在配置数据源、端口号、服务名称这些配置时并不会出现黄色警告，但是一些自定义的配置项则会出现<code>一片黄色的骇人景象</code>。</p>
<p><img    class="lazyload" data-original="https://s2.loli.net/2022/04/26/HF7eK4CEIAsTL5y.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">正常的项目配置</span></p>
<p><img    class="lazyload" data-original="https://s2.loli.net/2022/04/26/5Mxg2oscKYwlab8.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">自定义的配置项</span></p>
<p>虽然有警告，但是这并不是致命错误，因为你仍然可以正常的使用 <code>@Value(&quot;$&#123;test.a&#125;&quot;)</code> 来取值，但是作为有代码洁癖的人，这不能忍！而且 <code>@Value</code> 这种方式很容易因大意导致名称不一致，进而引起无法取值。</p>
<h1 id="主角登场"><a href="#主角登场" class="headerlink" title="主角登场"></a>主角登场</h1><p>我们先去没有警告的配置项 <code>spring.datasource.url</code> 代码内部，看看是怎么写的，能不能找点蛛丝马迹。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(</span><br><span class="hljs-meta">    prefix = &quot;spring.datasource&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceProperties</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanClassLoaderAware</span>, InitializingBean &#123;<br>    <span class="hljs-keyword">private</span> ClassLoader classLoader;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">generateUniqueName</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DataSource</span>&gt; type;<br>    <span class="hljs-keyword">private</span> String driverClassName;<br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> String jndiName;<br>    <span class="hljs-comment">//省略后部代码........</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>英语稍懂一些就会立刻注意到 <code>@ConfigurationProperties</code> 这个注解，因为它与我们此次要解决的问题非常相近，翻译过来就是 <code>配置属性</code>。</p>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>没错，<code>@ConfigurationProperties</code> 注解就是解决配置文件警告的关键，那么他是如何使用的？</p>
<h2 id="关系映射实体类"><a href="#关系映射实体类" class="headerlink" title="关系映射实体类"></a>关系映射实体类</h2><p>像使用 <code>MyBatisPlus</code> 那样，我们需要先创建一个 <code>关系映射实体类</code>，目的是告诉 Spring，服务启动时你把哪些配置项的值给我塞到这个实体类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zyan.test.pojo.properties;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.NestedConfigurationProperty;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestProperties</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String aProperty;<br><br>    <span class="hljs-keyword">private</span> String b;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">enable</span> <span class="hljs-operator">=</span> Boolean.FALSE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要注意这个实体类必须包含 <code>Setter</code> 和 <code>Getter</code> 方法，否则你将取不到值和无法取值。并且这个类必须使用 <code>@Component</code> 注解交由 Spring 管理，或者在服务启动类上使用 <code>@ConfigurationPropertiesScan</code> 注解进行扫描。</p>
<p><code>@ConfigurationProperties</code> 注解的 <code>prefix</code> 用于指定配置项前缀，可以使用 <code>.</code> 进行多级指定。不能使用驼峰命名，只能使用 <code>-</code> 进行分词。</p>
<p>可以直接在此类中为属性赋上默认值。</p>
<h2 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TestProperties testProperties;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>         System.out.println(<span class="hljs-string">&quot;配置项 test.enable 取值:&quot;</span> + testProperties.getEnable());<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>将 <code>TestProperties</code> 注入到适当的位置，通过 <code>Getter</code> 方法进行取值。此处使用 <code>@RequiredArgsConstructor</code> 进行构造器注入，想要详细了解使用方法，可阅读 <a href="/2020/10/30/Spring/base/RequiredArgsConstructor/">如何优雅的进行 Bean 注入</a>。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">test:</span><br>  <span class="hljs-attr">a-property:</span> <span class="hljs-string">xxx</span><br>  <span class="hljs-attr">b:</span> <span class="hljs-string">xxx</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<p>按照习惯，建议在 <code>.yml</code> 文件中使用 <code>-</code> 进行分词，在实体类中使用驼峰命名，不要担心这样无法取值，<code>Spring</code> 会帮你进行转化，当然，你也可以选择不这么做。</p>
<h1 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h1><h2 id="多级配置"><a href="#多级配置" class="headerlink" title="多级配置"></a>多级配置</h2><p>多级配置只需要引入静态内部类即可</p>
<h3 id="映射类写法"><a href="#映射类写法" class="headerlink" title="映射类写法"></a>映射类写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestProperties</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Other other;<br><br>    <span class="hljs-meta">@Data</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Other</span> &#123;<br>        <span class="hljs-keyword">private</span> String a;<br>        <span class="hljs-keyword">private</span> String b;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="yml-文件写法"><a href="#yml-文件写法" class="headerlink" title="yml 文件写法"></a>yml 文件写法</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">test:</span><br>  <span class="hljs-attr">other:</span><br>    <span class="hljs-attr">a:</span> <span class="hljs-string">xxx</span><br>    <span class="hljs-attr">b:</span> <span class="hljs-string">xxx</span><br></code></pre></td></tr></table></figure>

<h2 id="列表配置"><a href="#列表配置" class="headerlink" title="列表配置"></a>列表配置</h2><h3 id="映射类写法-1"><a href="#映射类写法-1" class="headerlink" title="映射类写法"></a>映射类写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestProperties</span> &#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;Other&gt; otherList;<br><br>    <span class="hljs-meta">@Data</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Other</span> &#123;<br>        <span class="hljs-keyword">private</span> String a;<br>        <span class="hljs-keyword">private</span> String b;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="yml-文件写法-1"><a href="#yml-文件写法-1" class="headerlink" title="yml 文件写法"></a>yml 文件写法</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">test:</span><br>  <span class="hljs-attr">other-list:</span><br>    <span class="hljs-bullet">-</span><br>      <span class="hljs-attr">a:</span> <span class="hljs-string">xxx</span><br>      <span class="hljs-attr">b:</span> <span class="hljs-string">xxx</span><br>    <span class="hljs-bullet">-</span><br>      <span class="hljs-attr">a:</span> <span class="hljs-string">xxx</span><br>      <span class="hljs-attr">b:</span> <span class="hljs-string">xxx</span><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring 相关</tag>
      </tags>
  </entry>
  <entry>
    <title>学会使用 BigDecimal</title>
    <url>/2020/07/15/Java/JavaBase/BigDecimal/</url>
    <content><![CDATA[<p><code>BigDecimal</code> 是 Java 提供的一个关于小数精确计算的类，其位于<code>java.math</code>包下。</p>
<p>不同于基本数据类型，<code>BigDecimal</code>是调用相关方法来进行运算。因为其拥有非常精确的小数计算能力，所以比较适合用于财务相关的计算等等。但是，其运行效率是不及 <code>Float</code> 与 <code>Double</code> 的，要按照实际情况，运用在合理的地方。</p>
<span id="more"></span>

<h1 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h1><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;99.6&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//不建议使用</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">99.6</span>);<br></code></pre></td></tr></table></figure>

<p>强烈建议使用 String 类型进行初始化对象，强烈不推荐使用 Double 类型。原因何在？我们来看一个小测试。</p>
<p>执行下方代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">BigDecimal bigDecimal=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;99.6&quot;</span>);<br>System.out.println(bigDecimal.toString());<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">99</span>.<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>

<p>而执行下方代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">BigDecimal bigDecimal=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">99.6</span>);<br>System.out.println(bigDecimal.toString());<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">99</span>.<span class="hljs-number">599999999999994315658113919198513031005859375</span><br></code></pre></td></tr></table></figure>

<p>问题立刻显现出来，使用 Double 型数据初始化 Bigdecimal 是不精确的，会损失精度。这不是 BigDecimal 的问题，而属于 Double 本身。在 IDEA 中，使用 Double 初始化时，则会“报黄”警告。&#x3D;&#x3D;所以请务必使用 String 初始化 BigDecimal !&#x3D;&#x3D;</p>
<p><img    class="lazyload" data-original="https://i.loli.net/2020/07/15/iGtUM7VnseTyJSc.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">IDEA 警告</span></p>
<h1 id="建议的数据库解决方案"><a href="#建议的数据库解决方案" class="headerlink" title="建议的数据库解决方案"></a>建议的数据库解决方案</h1><p>基于上一部分得到的结论，建议在数据库中使用<code> VARCHAR</code> 类型或者 <code>DECIMAL</code>，这里以 MySQL + MyBatis 为例。</p>
<table>
<thead>
<tr>
<th>数据库数据类型</th>
<th>MyBatis 实体类数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>VARCHAR</td>
<td>String</td>
</tr>
<tr>
<td>DECIMAL</td>
<td>BigDecimal</td>
</tr>
</tbody></table>
<h1 id="加减运算"><a href="#加减运算" class="headerlink" title="加减运算"></a>加减运算</h1><blockquote>
<p>加减运算比较简单，使用 <code>add()</code> 与 <code>subtract()</code> 方法进行处理。</p>
</blockquote>
<h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;99.6&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">subtract</span> <span class="hljs-operator">=</span> bigDecimal.subtract(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;66.9&quot;</span>));<br>System.out.println(subtract.toString());<br>System.out.println(bigDecimal.toString());<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">32</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">99</span>.<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>

<p>此处需要注意的是，&#x3D;&#x3D;所有的运算方法在执行后并不会影响参与计算的数，他只会将计算结果返回！&#x3D;&#x3D;</p>
<p>你可以使用新的对象来接受，或者覆盖旧的对象。</p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;99.6&quot;</span>);<br>bigDecimal = bigDecimal.subtract(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;66.9&quot;</span>));<br>System.out.println(bigDecimal.toString());<br></code></pre></td></tr></table></figure>

<h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;99.6&quot;</span>);<br>bigDecimal = bigDecimal.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;66.9&quot;</span>));<br>System.out.println(bigDecimal.toString());<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">166</span>.<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>


<h1 id="乘除运算"><a href="#乘除运算" class="headerlink" title="乘除运算"></a>乘除运算</h1><h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><p>使用 <code>multiply()</code>方法进行处理。</p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;99.6&quot;</span>);<br>bigDecimal = bigDecimal.multiply(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;66.9&quot;</span>));<br>System.out.println(bigDecimal.toString());<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">6663</span>.<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure>

<h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><blockquote>
<p>除法是比较特殊的一个运算，因为除数与被除数的关系，可能会造成结果为<code>无限循环小数</code>或<code>无限不循环小数</code>，为了解决这一问题你需要指定<code>小数保留方案</code>。</p>
</blockquote>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;99.6&quot;</span>);<br>bigDecimal = bigDecimal.divide(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;3&quot;</span>));<br>System.out.println(bigDecimal.toString());<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">33</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>因为该运算结果不是<code>无限循环小数</code>，所以一切看起来都很 Nice ，但是当你稍稍改动一下，它就会“原形毕露”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;99.6&quot;</span>);<br>bigDecimal = bigDecimal.divide(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;66.9&quot;</span>));<br>System.out.println(bigDecimal.toString());<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<p style="color:red;">
    Exception in thread "main" java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.
    at java.math.BigDecimal.divide(BigDecimal.java:1690)
    at ...
<p>

<p>我是谁？我在哪？我写的是什么BUG？我们来看关键字<code>Non-terminating decimal expansion</code>，翻译过来就是<code>无穷小数扩张</code>。看到这里，你是否已经明白问题所在。也就是上边所提到的，需要指定<code>小数保留方案</code>。</p>
<p>改动一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;99.6&quot;</span>);<br>bigDecimal = bigDecimal.divide(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;66.9&quot;</span>),<span class="hljs-number">2</span>,BigDecimal.ROUND_DOWN);<br>System.out.println(bigDecimal.toString());<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.<span class="hljs-number">48</span><br></code></pre></td></tr></table></figure>

<p>此时一切都已恢复往日的平静，那么到底是什么力量遏制住了可恶的 Exception 呢？细心的同学会发现在 <code>divide()</code>方法中多了两个参数，一个是<code>2</code>，一个是<code>BigDecimal.ROUND_DOWN</code>。其中，2是保留小数的位数，这个很容易理解。而<code>BigDecimal.ROUND_DOWN</code>又是什么东西呢？他是 BigDecimal 类中的小数保留方案常量，算上这一个，一共有八个方案常量，请看解析。</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BigDecimal.ROUND_UP</td>
<td align="left">舍入远离零的舍入模式。在丢弃非零部分之前始终增加数字(始终对非零舍弃部分前面的数字加1)。</td>
</tr>
<tr>
<td align="left">BigDecimal.ROUND_DOWN</td>
<td align="left">接近零的舍入模式。在丢弃某部分之前始终不增加数字(从不对舍弃部分前面的数字加1，即截短)。</td>
</tr>
<tr>
<td align="left">BigDecimal.ROUND_CEILING</td>
<td align="left">接近正无穷大的舍入模式。如果 BigDecimal 为正，则舍入行为与 ROUND_UP 相同；如果为负，则舍入行为与 ROUND_DOWN 相同。</td>
</tr>
<tr>
<td align="left">BigDecimal.ROUND_FLOOR</td>
<td align="left">接近负无穷大的舍入模式。如果 BigDecimal 为正，则舍入行为与 ROUND_DOWN 相同；如果为负，则舍入行为与 ROUND_UP 相同。</td>
</tr>
<tr>
<td align="left">BigDecimal.ROUND_HALF_UP</td>
<td align="left">向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式。如果舍弃部分 &gt;&#x3D; 0.5，则舍入行为与 ROUND_UP 相同;否则舍入行为与 ROUND_DOWN 相同。注意，这是我们大多数人在小学时就学过的舍入模式(四舍五入)。</td>
</tr>
<tr>
<td align="left">BigDecimal.ROUND_HALF_DOWN</td>
<td align="left">向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为上舍入的舍入模式。如果舍弃部分 &gt; 0.5，则舍入行为与 ROUND_UP 相同;否则舍入行为与 ROUND_DOWN 相同(五舍六入)。</td>
</tr>
<tr>
<td align="left">BigDecimal.ROUND_HALF_EVE</td>
<td align="left">向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。如果舍弃部分左边的数字为奇数，则舍入行为与 ROUND_HALF_UP 相同；如果为偶数，则舍入行为与 ROUND_HALF_DOWN 相同。此舍入模式也称为“银行家舍入法”，主要在美国使用。</td>
</tr>
<tr>
<td align="left">BigDecimal.ROUND_UNNECESSARY</td>
<td align="left">断言请求的操作具有精确的结果，因此不需要舍入。如果对获得精确结果的操作指定此舍入模式，则抛出ArithmeticException。</td>
</tr>
</tbody></table>
<p>这么多的小数保留方案，其实常用的也不多，感兴趣的话，可以自己写个测试类玩玩。</p>
<h1 id="比较大小"><a href="#比较大小" class="headerlink" title="比较大小"></a>比较大小</h1><blockquote>
<p>比较大小也是需要调用方法的，使用<code>compareTo()</code>方法即可处理。</p>
</blockquote>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;99.6&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;66.9&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a.compareTo(b);<br>System.out.println(i);<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure>

<p><code>compareTo()</code>方法的返回值是一个<code>int</code>型的数据，以上方示例为例，请看解析</p>
<table>
<thead>
<tr>
<th align="left">情况</th>
<th align="left">compareTo() 的返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">a&gt;b</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">a&#x3D;b</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">a&lt;b</td>
<td align="left">-1</td>
</tr>
</tbody></table>
<p>当你要判断一个数的与0的关系（正负）时可以这样写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-99.6&quot;</span>);<br><span class="hljs-keyword">if</span> (a.compareTo(BigDecimal.ZERO) &gt; <span class="hljs-number">0</span>) &#123;<br>	<span class="hljs-comment">//a是正数</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.compareTo(BigDecimal.ZERO) == <span class="hljs-number">0</span>)&#123;<br>	<span class="hljs-comment">//a==0</span><br>&#125;<span class="hljs-keyword">else</span> &#123;<br>	<span class="hljs-comment">//a是负数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="去除无用的零"><a href="#去除无用的零" class="headerlink" title="去除无用的零"></a>去除无用的零</h2><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;99.12300000&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a.stripTrailingZeros();<br>System.out.println(b.toString());<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">99</span>.<span class="hljs-number">123</span><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>将List转换为树形结构</title>
    <url>/2022/08/19/Java/JavaBase/ConvertListToTree/</url>
    <content><![CDATA[<p>在 Java 中，把<code>List</code> 转换为多级的树形结构非常常见。例如菜单数据是在数据库中“平铺”存储的，在做查询时，需要将其转换为树形结构，方便前端进行展示。</p>
<p>本文就以菜单作为案例，读者可以举一反三，实现自己的需求</p>
<h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><p>将其命名为<code>PERMISSIONS</code></p>
<table>
<thead>
<tr>
<th align="left">字段名</th>
<th align="left">类型</th>
<th align="left">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CODE</td>
<td align="left">varchar</td>
<td align="left">编码(主键)</td>
</tr>
<tr>
<td align="left">PARENT_CODE</td>
<td align="left">varchar</td>
<td align="left">父编码</td>
</tr>
<tr>
<td align="left">NAME</td>
<td align="left">varchar</td>
<td align="left">名称</td>
</tr>
<tr>
<td align="left">TYPE</td>
<td align="left">tinyint</td>
<td align="left">类型 0菜单 1按钮 2接口</td>
</tr>
<tr>
<td align="left">URL</td>
<td align="left">varchar</td>
<td align="left">前端路由或后端接口路由</td>
</tr>
<tr>
<td align="left">CREATE_TIME</td>
<td align="left">datetime</td>
<td align="left">创建时间</td>
</tr>
<tr>
<td align="left">UPDATE_TIME</td>
<td align="left">datetime</td>
<td align="left">更新时间</td>
</tr>
</tbody></table>
<h1 id="Java-处理"><a href="#Java-处理" class="headerlink" title="Java 处理"></a>Java 处理</h1><p>假设我们此时已经查询出一个列表<code>List&lt;Permissions&gt;</code>，<code>Permissions</code>类是与数据库对应的实体类，包含了<code>PERMISSIONS</code>表的所有字段，此刻就需要对其进行树形结构处理。</p>
<h2 id="树形结构实体类"><a href="#树形结构实体类" class="headerlink" title="树形结构实体类"></a>树形结构实体类</h2><p>首先我们需要一个包含自身的树形结构实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 权限树内容</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@EqualsAndHashCode(callSuper = true)</span><br><span class="hljs-meta">@ApiModel(description = &quot;权限树内容&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PermissionsTreeRes</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Permissions</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">3107598961006613967L</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 权限树</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ApiModelProperty(&quot;权限树&quot;)</span><br>    <span class="hljs-keyword">private</span> List&lt;PermissionsTreeRes&gt; children;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>PermissionsTreeRes</code>继承了<code>Permissions</code>，即拥有了数据库表中的所有字段。其自身又包含了类型为<code>List&lt;PermissionsTreeRes&gt;</code>的<code>children</code>属性，即子节点。</p>
<h2 id="代码处理"><a href="#代码处理" class="headerlink" title="代码处理"></a>代码处理</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;PermissionsTreeRes&gt; <span class="hljs-title function_">buildPermissionsTree</span><span class="hljs-params">(List&lt;Permissions&gt; permissionsList)</span> &#123;<br>    <span class="hljs-keyword">return</span> permissionsList.stream().filter(permissions -&gt; ObjectUtils.isEmpty(permissions.getParentCod()))<br>            .map(permissions -&gt; &#123;<br>                <span class="hljs-type">PermissionsTreeRes</span> <span class="hljs-variable">treeRes</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PermissionsTreeRes</span>();<br>                BeanUtils.copyProperties(permissions, treeRes);<br>                treeRes.setChildren(<span class="hljs-built_in">this</span>.getPermissionsChildrenList(permissions.getCode(),permissionsList));<br>                <span class="hljs-keyword">return</span> treeRes;<br>            &#125;).collect(Collectors.toList());<br>&#125;<br><br><span class="hljs-keyword">private</span> List&lt;PermissionsTreeRes&gt; <span class="hljs-title function_">getPermissionsChildrenList</span><span class="hljs-params">(String code, List&lt;Permissions&gt;permissionsList)</span> &#123;<br>    <span class="hljs-keyword">return</span> permissionsList.stream().filter(permissions -&gt; StringUtils.equals(permissions.getParentCode(),code))<br>            .map(permissions -&gt; &#123;<br>                <span class="hljs-type">PermissionsTreeRes</span> <span class="hljs-variable">treeRes</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PermissionsTreeRes</span>();<br>                BeanUtils.copyProperties(permissions, treeRes);<br>                treeRes.setChildren(<span class="hljs-built_in">this</span>.getPermissionsChildrenList(permissions.getCode(),permissionsList));<br>                <span class="hljs-keyword">return</span> treeRes;<br>            &#125;).collect(Collectors.toList());<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>buildPermissionsTree()</code>方法内使用<code>ObjectUtils.isEmpty(permissions.getParentCod())</code>条件筛选出所有父编码为空的数据，即一级菜单数据。遍历中的<code>setChildren()</code>调用了<code>getPermissionsChildrenList()</code>方法，并传入自身的<code>CODE</code>，去寻找自己的子节点。</p>
</li>
<li><p><code>getPermissionsChildrenList()</code>方法内使用递归不断的向下查找，直至<code>filter</code>后再无数据，便停止递归，进入下一次遍历。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 函数式编程</title>
    <url>/2022/03/04/Java/JavaBase/FunctionalProgramming/</url>
    <content><![CDATA[<p>从 Java 8 开始，便拥有了函数式编程的能力。这个能力通俗来讲，就是可以把一个方法实现（也可简单的理解为代码片段）作为参数进行传递，并在适当的时候执行。</p>
<p>Java 有内置的一些类或工具就使用到这个特性，例如整理集合时所使用的<code>stream()</code></p>
<p>其实在真实的项目开发中，使用这个特性的人并不多。然而在一次偶然的开发过程中，让我深刻理解到这个特性的重要程度，以及它能为代码结构带来多大的优化空间。</p>
<h1 id="为什么要使用它？"><a href="#为什么要使用它？" class="headerlink" title="为什么要使用它？"></a>为什么要使用它？</h1><h2 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h2><p>我们来看一个代码场景，现在有一个<code>Procedure</code>类，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Procedure</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">test1</span><span class="hljs-params">(Integer t)</span> &#123;<br>        <span class="hljs-keyword">return</span> t + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">test2</span><span class="hljs-params">(Integer t)</span> &#123;<br>        <span class="hljs-keyword">return</span> t + <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">test3</span><span class="hljs-params">(Integer t)</span> &#123;<br>        <span class="hljs-keyword">return</span> t + <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>还有一个<code>Share</code>类，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Share</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> Procedure.test1(i);<br>            System.out.println(<span class="hljs-string">&quot;代码第&quot;</span> + i + <span class="hljs-string">&quot;次执行结果:&quot;</span> + value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> Procedure.test2(i);<br>            System.out.println(<span class="hljs-string">&quot;代码第&quot;</span> + i + <span class="hljs-string">&quot;次执行结果:&quot;</span> + value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">c</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> Procedure.test3(i);<br>            System.out.println(<span class="hljs-string">&quot;代码第&quot;</span> + i + <span class="hljs-string">&quot;次执行结果:&quot;</span> + value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>想想怎么优化<code>Share</code>类里的<code>a() b() c()</code>方法，提高代码的复用性，优化不允许变更<code>a() b() c()</code>方法的功能。</p>
<h2 id="一般优化"><a href="#一般优化" class="headerlink" title="一般优化"></a>一般优化</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Share</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> Procedure.test1(i);<br>            println(i, value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> Procedure.test2(i);<br>            println(i, value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">c</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> Procedure.test3(i);<br>            println(i, value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">println</span><span class="hljs-params">(Integer index, Integer value)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;代码第&quot;</span> + index + <span class="hljs-string">&quot;次执行结果:&quot;</span> + value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>仿佛最大的优化，也只能把打印结果的那一行代码抽出，作为公共的方法使用。</p>
<h2 id="函数式是最优解"><a href="#函数式是最优解" class="headerlink" title="函数式是最优解"></a>函数式是最优解</h2><p>通过分析可以看出，三个方法里的<code>for</code>循环是一模一样的，唯一的不同点就是这三个方法都有自己的调用逻辑：<code>a()</code>调用<code>Procedure.test1(Integer)</code>，<code>b()</code>调用<code>Procedure.test2(Integer)</code>，<code>c()</code>调用<code>Procedure.test3(Integer)</code>。</p>
<p>那么我们就可以把这个调用逻辑作为一个方法的实现内容进行传递，交给<code>println()</code>方法，让其在适当的地方调用。</p>
<p>这个时候，函数式编程就像魔法一样，把这个类的代码结构优化到淋漓尽致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Share</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//简写</span><br>        println(Procedure::test1);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//简写</span><br>        println(Procedure::test2);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">c</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//为了讲解，此处使用完整写法</span><br>        println((t)-&gt;&#123;<br>            <span class="hljs-keyword">return</span> Procedure.test3(t);<br>        &#125;);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">println</span><span class="hljs-params">(Function&lt;Integer, Integer&gt; func)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> func.apply(i);<br>            System.out.println(<span class="hljs-string">&quot;代码第&quot;</span> + i + <span class="hljs-string">&quot;次执行结果:&quot;</span> + value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        a();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Java-内置的函数式接口"><a href="#Java-内置的函数式接口" class="headerlink" title="Java 内置的函数式接口"></a>Java 内置的函数式接口</h1><p>Java 是一种强类型语言，所以在函数式编程这一特性也不例外，它不能像 JS 那样可以将任何形式（这里指参数、返回值）的函数进行传递，而是必须在函数接受方显式的规定该函数的数据类型等细节。</p>
<p>Java 利用泛型内置了一些可以灵活使用的函数式接口，你可以通过指定这些接口的泛型达到定制化的目的，来满足一般的开发需求。</p>
<h2 id="接口名称关键字整理"><a href="#接口名称关键字整理" class="headerlink" title="接口名称关键字整理"></a>接口名称关键字整理</h2><p>由于内置的函数式接口较多，这里就不再一一列举，可以<a href="https://www.runoob.com/java/java8-functional-interfaces.html">点击访问菜鸟教程网站</a>进行查阅</p>
<p>不过我发现这些接口的名称和他们的场景用途存在一定的规律，特地整理一份关键字的对照表。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>返回值</th>
<th>参数</th>
<th>执行</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer</td>
<td>无返回结果</td>
<td>有参数</td>
<td>accept方法</td>
</tr>
<tr>
<td>Supplier</td>
<td>有返回结果</td>
<td>无参数</td>
<td>get方法</td>
</tr>
<tr>
<td>Function</td>
<td>有返回结果</td>
<td>有参数</td>
<td>apply方法</td>
</tr>
<tr>
<td>Predicate</td>
<td>有返回结果，且结果为布尔值</td>
<td>有参数</td>
<td>test方法</td>
</tr>
<tr>
<td>Operator</td>
<td>有返回结果，且参数和返回结果数据类型相同</td>
<td>有参数，且参数和返回结果数据类型相同</td>
<td>apply方法</td>
</tr>
</tbody></table>
<h1 id="如何自定义函数式接口"><a href="#如何自定义函数式接口" class="headerlink" title="如何自定义函数式接口"></a>如何自定义函数式接口</h1><p>当 Java 内置的函数式接口不能满足开发需求时（例如接口的参数数量很多），你可以自己定义一个函数式接口来使用。</p>
<p>当然，出于个人喜好、项目管理等原因，你也可以在项目中完全使用自定义的函数式接口，放弃所有的内置函数式接口。</p>
<p>下面就是一个标准的函数式接口，看起来与普通的接口定义没有什么不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zyan.test;<br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestInterFace</span> &#123;<br><br>    Integer <span class="hljs-title function_">test</span><span class="hljs-params">(String a, String b, String c, String d)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此处需要注意的是，经过实践，<code>@FunctionalInterface</code>注解并不是必须的，出于习惯的原因，我都会加上该注解。</p>
<p><strong>自定义函数式接口需要满足：有且只有一个未实现的方法。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>如何优雅的进行 Bean 注入</title>
    <url>/2020/10/30/Spring/base/RequiredArgsConstructor/</url>
    <content><![CDATA[<p>不知道为什么，最近听到许多反对使用<code>Lombok</code>的声音，说什么影响代码可读性，具有侵入性。（弱弱的问一句，<code>Entity</code>要什么可读性？）这是我从上学的时候认识<code>Lombok</code>以来，第一次听到这样的声音。</p>
<span id="more"></span>

<p>在我看来，<code>Lombok</code>大大提高了开发效率。举个栗子，在我最近工作所开发的ERP系统中，由于行业的特殊性，一张表动辄七八十个字段，难道你会为<code>Entity</code>一个一个的去写<code>set</code>和<code>get</code>方法？或者说使用一些工具去生成？反正我打死都不会干的，毕竟人类只有越来越“懒”，才会想尽一切办法去提高生产力。</p>
<p>这篇文章暂且不谈<code>Lombok</code>的优劣，最近我在爬帖子时发现了一个注解，可以优雅的在 <code>Spring</code> 项目中进行 <code>Bean</code> 注入：<code>@RequiredArgsConstructor</code>，这个注解则由<code>Lombok</code>提供。从这个单词来理解，大致就是，<code>必须的参数构造器</code>，那么这个注解又是怎么和<code>Bean</code>注入扯上关系的？向下看。</p>
<h1 id="Bean注入乱象"><a href="#Bean注入乱象" class="headerlink" title="Bean注入乱象"></a>Bean注入乱象</h1><p><code>Spring</code>提供了三种注入模式，一种是<code>属性注入</code>(Filed injection)，一种是通过<code>setter</code>方法，一种是<code>构造器注入</code>。就目前情况来看，许多的项目看起来应该是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ARepo aRepo;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> BRepo bRepo;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> CRepo cRepo;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DRepo dRepo;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ERepo eRepo;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样的使用方法本身没有什么问题，看起来还蛮整洁哈，可真实项目里却是这样的：</p>
<p><img    class="lazyload" data-original="https://i.loli.net/2020/10/30/prTUYI6gBobwP9F.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">真实项目截图</span></p>
<p><code>Spring</code>从4.0开始，<strong>就 不 推 荐 使 用 属 性 注 入 模 式 了，</strong>原因是它可以让我们忽略掉一些代码可能变坏的隐患，同时这样的写法也使<code>IDEA</code>向你发出<code>黄色警告</code>!</p>
<p>既然<code>Spring</code>推荐使用显式的<code>Setter</code>和<code>构造器方式</code>，那我们就切换一下实现方案。</p>
<h1 id="这个样子很优雅"><a href="#这个样子很优雅" class="headerlink" title="这个样子很优雅"></a>这个样子很优雅</h1><p><code>Setter</code>方式显然不可能，我可不想把<code>Setter</code>代码生成工具玩到吐，那么就剩下了<code>构造器方式</code>，就像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ARepo aRepo;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserServiceImpl</span> <span class="hljs-params">(ARepo aRepo)</span> &#123;<br>        <span class="hljs-built_in">this</span>.aRepo = aRepo;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>或者……像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ARepo aRepo;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BRepo bRepo;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CRepo cRepo;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DRepo dRepo;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ERepo eRepo;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserServiceImpl</span> <span class="hljs-params">(ARepo aRepo,BRepo bRepo,CRepo cRepo</span><br><span class="hljs-params">                            ,DRepo dRepo,ERepo eRepo)</span> &#123;<br>        <span class="hljs-built_in">this</span>.aRepo = aRepo;<br>        <span class="hljs-built_in">this</span>.bRepo = bRepo;<br>        <span class="hljs-built_in">this</span>.cRepo = cRepo;<br>        <span class="hljs-built_in">this</span>.dRepo = dRepo;<br>        <span class="hljs-built_in">this</span>.eRepo = eRepo;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>emmm，要是这样的话，我宁愿用<code>@Autowired</code>。</p>
<p>当注入的<code>Bean</code>变多之后，构造器便显得超级臃肿，这个时候<code>@RequiredArgsConstructor</code>就派上了大用场，来看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <br>    <span class="hljs-keyword">final</span> ARepo aRepo;<br>    <span class="hljs-keyword">final</span> BRepo bRepo;<br>    <span class="hljs-keyword">final</span> CRepo cRepo;<br>    <span class="hljs-keyword">final</span> DRepo dRepo;<br>    <span class="hljs-keyword">final</span> ERepo eRepo;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>嗯，这才是我们想要的样子，相信聪明的你已经明白了<code>@RequiredArgsConstructor</code>会在编译时帮你生成那个又臭又长的构造器，达到了<code>Bean</code>注入的目的。</p>
<p>好了，如此优雅的注入，还不快拿去享用。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>相对规范的服务API应如何实现</title>
    <url>/2022/08/18/Spring/base/StandardApi/</url>
    <content><![CDATA[<blockquote>
<p>标准规范的接口可以降低前后端开发人员之间的沟通成本，并且能够降低后端服务自身的后期维护难度。</p>
</blockquote>
<h1 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h1><p>请求与响应参数是前后端开发人员对接的重要关注点，如果后端 API 不能向前端（甚至是自己）清晰的传达<strong>我接收什么，我返回什么</strong>的问题，那么对于双方来说，这都是一种灾难。</p>
<h2 id="通用的-ApiResult"><a href="#通用的-ApiResult" class="headerlink" title="通用的 ApiResult"></a>通用的 <code>ApiResult</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiResult</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">2747440445733983051L</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 状态</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer status;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String msg;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 响应数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> T payload;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 程序异常信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String exception;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是一个简单的<code>ApiResult</code>示例，你所开发的每一个接口响应参数都应该是它，它是<strong>处于顶层的响应参数结构</strong>，通过指定不同的泛型适应各个接口的需求。各个参数作用如下:</p>
<ul>
<li>status <strong>状态码</strong>，用不同的数字表示当前接口处理完成后的结果状态。请不要与 Http 的状态混为一谈，我们不希望直接使用 Http 的状态来表示。 Http 的状态每次请求都应该是 200 的，处理的结果应由响应参数来体现。</li>
<li>msg <strong>信息</strong>，后端服务提示用户消息的主要途径，因为许多的提示信息（正确或错误）都是在后端程序执行过程中才会出现。一般这个信息前端需要使用弹窗、横幅或其他手段去传达给用户。</li>
<li>payload <strong>响应数据</strong>，这个参数可以是任何数据类型，它是接口响应的具体业务数据。</li>
<li>exception <strong>程序异常信息</strong>，结合自己的开发经验，觉得需要这样一个参数来帮助开发者更快的定位问题。例如发生某个异常，这个参数可以是该异常的具体信息<code>e.getMessage()</code>，所以开发人员只需通过浏览器开发者工具就能找到发生异常的原因。注意这个信息是不能传达给用户的！</li>
</ul>
<p>可以根据自己的习惯去命名这些参数，也可以为<code>ApiResult</code>扩展一些常用的方法，使得接口在构建响应参数时更加方便。</p>
<h2 id="状态码枚举"><a href="#状态码枚举" class="headerlink" title="状态码枚举"></a>状态码枚举</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ApiStatusEnum</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 成功</span><br><span class="hljs-comment">     */</span><br>    SUCCESS(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;处理成功&quot;</span>),<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 未授权（登录信息有误，需要重新登录）</span><br><span class="hljs-comment">     */</span><br>    UNAUTHORIZED(<span class="hljs-number">401</span>, <span class="hljs-string">&quot;未授权（登录信息有误 需要重新登录）&quot;</span>),<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 无操作权限</span><br><span class="hljs-comment">     */</span><br>    NO_PERMISSIONS(<span class="hljs-number">403</span>, <span class="hljs-string">&quot;无操作权限&quot;</span>),<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 失败</span><br><span class="hljs-comment">     */</span><br>    FAIL(<span class="hljs-number">500</span>, <span class="hljs-string">&quot;处理失败&quot;</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 状态码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer status;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 提示消息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String msg;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是一个状态码枚举示例，它的<code>status</code>最终会体现在<code>ApiResult</code>的<code>status</code>中，前端得以根据不同的状态码进行逻辑处理，可以根据业务需要进行添加。可以参考 http 标准的状态码列举，但是一般与业务相近的 http 状态码少之又少，所以<strong>按照数字顺序不断自增列举</strong>的方式也是可取的。</p>
<h2 id="使用实体类声明请求与响应参数"><a href="#使用实体类声明请求与响应参数" class="headerlink" title="使用实体类声明请求与响应参数"></a>使用实体类声明请求与响应参数</h2><p><strong>一个优秀的 API 接口，是不需要翻阅具体代码就能知道它的请求与响应参数的。</strong></p>
<p>不知道有多少人喜欢使用<code>Map</code>或者类似于<code>Map</code>的类去接收和响应数据，甚至是使用<code>String</code>搭配一些 Json 工具去处理。这是非常愚蠢的操作。当然，爽是真的爽，但是这样的爽非常自私。对于调用者<sub>1</sub>来说，这样的的接口就像是一个黑盒子，必须翻阅具体的代码才能看到它接收什么、返回什么。可是他只想调用一下这个接口，至于里边怎么做的他不需要关心。这合理吗？这一点都不合理！</p>
<p>使用实体类声明就能很好的避免这个问题，因为它能够严格规定这个接口的请求与返回，不是<code>Map</code>、<code>String</code>这样的“来者不拒“。</p>
<p>[1] 调用者：在微服务架构下，许多接口不仅向前端提供，也会向其他服务提供，此处的调用者指后端开发人员。</p>
<h3 id="如何管理这些实体类"><a href="#如何管理这些实体类" class="headerlink" title="如何管理这些实体类"></a>如何管理这些实体类</h3><p>个人经验，觉得<strong>每一个接口都应该拥有自己独立的参数实体类</strong>。</p>
<p>一些人喜欢使用<code>DTO</code>和<code>VO</code>作为后缀命名接口的参数，我个人更喜欢使用<code>Req</code>和<code>Res</code>作为后缀，也向你推荐使用这种方式，因为它更加的贴切、一目了然。</p>
<p>举一个栗子🌰，有一个分页查询用户信息的接口、还有一个新增用户信息的接口，那么它的参数实体类位置以及命名应该像下面这个样子:</p>
<hr>
<ul>
<li>controller<ul>
<li>UserController.java <code>/user</code><ul>
<li><code>/pageList</code>接口，方法名为<code>pageList</code></li>
<li><code>/add</code> 接口，方法名为<code>add</code></li>
</ul>
</li>
</ul>
</li>
<li>mapper</li>
<li>pojo<ul>
<li>dto<ul>
<li>user<ul>
<li>pagelist<ul>
<li>UserPageListReq.java</li>
<li>UserPageListRes.java</li>
</ul>
</li>
<li>add<ul>
<li>UserAddReq.java</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>entity</li>
<li>properties</li>
<li>redis</li>
</ul>
</li>
<li>service</li>
<li>utils</li>
</ul>
<hr>
<p>先别急着骂！这样去管理这些实体类的确目录层级较多，比较麻烦。但是<strong>规范与效率两件事本来就是不可兼得的</strong>，在很多时候，我自己还是比较偏向于规范的。</p>
<p>这样做有什么好处呢，首先实体类的名称变得有迹可循、有规可依。其次接口参数实体类所在<code>dto</code>包下的目录和接口是一一对应的，有利于你看到接口参数实体类就能很快定位到使用它的接口，看到接口就能很快定位到它的参数实体类。所以<strong>今日所谓的麻烦是为了以后不会遇到更多的麻烦</strong>。</p>
<h1 id="推荐使用-Swagger"><a href="#推荐使用-Swagger" class="headerlink" title="推荐使用 Swagger"></a>推荐使用 Swagger</h1><p>Swagger 能够自动生成接口文档，可以交给前端同事 Swagger 地址作为接口对接依据，开展工作。也可以使用其进行快速的接口调用，进行接口自测。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="添加依赖并启用"><a href="#添加依赖并启用" class="headerlink" title="添加依赖并启用"></a>添加依赖并启用</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>SpringBoot 启动类上添加 <code>@EnableOpenApi</code> 注解</strong></p>
<h3 id="创建-SwaggerProperties"><a href="#创建-SwaggerProperties" class="headerlink" title="创建 SwaggerProperties"></a>创建 <code>SwaggerProperties</code></h3><p>通过配置在<code>yml</code>文件中的<code>enabled</code>参数来控制不同环境下Swagger是否开启。关于<code>yml</code>文件与<code>@ConfigurationProperties</code>可以参考另一篇文章<a href="/2022/03/10/Spring/correlation/SolveYmalWarn/">解决 Spring 配置文件警告</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;swagger&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerProperties</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否启用 Swagger，默认关闭</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">enabled</span> <span class="hljs-operator">=</span> Boolean.FALSE;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="创建-SwaggerConfig"><a href="#创建-SwaggerConfig" class="headerlink" title="创建 SwaggerConfig"></a>创建 <code>SwaggerConfig</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfig</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SwaggerProperties swaggerProperties;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">createRestApi</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.OAS_30)<br>                .enable(swaggerProperties.getEnabled())<br>                .apiInfo(apiInfo())<br>                .select()<br>                <span class="hljs-comment">//指定需要被 Swagger 扫描到的包名</span><br>                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.xxxxx.xxxx.controller&quot;</span>))<br>                .paths(PathSelectors.any())<br>                .build();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建该API的基本信息（这些基本信息会展现在文档页面中）</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ApiInfo</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title function_">apiInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                .title(<span class="hljs-string">&quot;xxx项目&quot;</span>)<br>                .description(<span class="hljs-string">&quot;&quot;</span>)<br>                .termsOfServiceUrl(<span class="hljs-string">&quot;&quot;</span>)<br>                .version(<span class="hljs-string">&quot;1.0&quot;</span>)<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>项目启动后就可以通过 <code>&#123;服务根路径&#125;/swagger-ui/</code> 去访问文档了，一定要注意，最后的反斜杠是必须的，否则无法访问。</p>
<h3 id="Api"><a href="#Api" class="headerlink" title="@Api"></a><code>@Api</code></h3><p><code>@Api</code>是<strong>放置在<code>Controller</code>类上</strong>的，例如用户的<code>UserController</code>可以这样去写：<code>@Api(tags = &quot;User-用户信息相关接口&quot;)</code></p>
<h3 id="ApiOperation"><a href="#ApiOperation" class="headerlink" title="@ApiOperation"></a><code>@ApiOperation</code></h3><p><code>@ApiOperation</code>是<strong>放置在具体接口上</strong>的，例如用户的<code>/pageList</code>接口可以这样去写：<code>@ApiOperation(value = &quot;分页查询用户信息&quot;)</code></p>
<h3 id="ApiModel"><a href="#ApiModel" class="headerlink" title="@ApiModel"></a><code>@ApiModel</code></h3><p><code>@ApiModel</code>是<strong>放置在请求或响应实体类上</strong>的，例如分页查询用户信息接口请求参数可以这样写：<code>@ApiModel(description = &quot;分页查询用户信息接口请求参数&quot;)</code></p>
<h3 id="ApiModelProperty"><a href="#ApiModelProperty" class="headerlink" title="@ApiModelProperty"></a><code>@ApiModelProperty</code></h3><p><code>@ApiModelProperty</code>是<strong>放置在请求或响应实体类的属性上</strong>的，例如保存用户信息接口请求参数的年龄属性可以这样写：<code>    @ApiModelProperty(value = &quot;年龄&quot;, required = true)</code></p>
<p>其中的<code>required</code>可以指定是否为必传字段，为 <code>true</code> 时文档中会为该属性添加红色星号，为 <code>true</code> 时可以忽略不写，例如<code>@ApiModelProperty(&quot;年龄&quot;)</code>，<strong>注意，他并不会帮你进行参数校验！</strong></p>
<h2 id="既然用了就落实下去"><a href="#既然用了就落实下去" class="headerlink" title="既然用了就落实下去"></a>既然用了就落实下去</h2><p>为什么会说既然用了就落实下去？我遇到很多的项目，用到了 Swagger，一些接口有他的影子，一些接口又没有他，前后端对接还是跟之前一样口头传达。所以，你要它有何用？</p>
<h1 id="请求参数校验"><a href="#请求参数校验" class="headerlink" title="请求参数校验"></a>请求参数校验</h1><p>使用<code>org.springframework.validation.annotation</code>包下的<code>@Validated</code>对请求参数进行合法性校验。</p>
<p>因SpringBoot版本不同，可能需要添加相应的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>以上文的保存用户信息接口请求参数的年龄属性为例，你可以这样做：</p>
<p>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/add&quot;)</span><br><span class="hljs-meta">@ApiOperation(value = &quot;保存用户信息&quot;)</span><br><span class="hljs-keyword">public</span> ApiResult&lt;?&gt; add(<span class="hljs-meta">@RequestBody</span> <span class="hljs-meta">@Validated</span> UserAddReq req) &#123;<br>    userService.add(req);<br>    <span class="hljs-keyword">return</span> ApiResult.success();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>请求参数实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.validation.constraints.NotNull;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ApiModel(description = &quot;保存用户信息请求参数&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserAddReq</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2749806305785349883L</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 年龄</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@NotNull(message = &quot;年龄不允许为空&quot;)</span><br>    <span class="hljs-meta">@ApiModelProperty(value = &quot;年龄&quot;, required = true)</span><br>    <span class="hljs-keyword">private</span> Integer age;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过<code>@NotNull</code>来指定<code>age</code>字段不允许为<code>null</code>，除此之外，还有很多的校验注解可以使用，可以<a href="https://javaee.github.io/javaee-spec/javadocs/javax/validation/constraints/package-summary.html">点击跳转查阅更多</a></p>
<p>校验不通过时，程序将会抛出异常来阻止继续运行！将在下文中说明如何优雅的处理校验不通过时的错误。</p>
<h1 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h1><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sincland.insurance.partner.config;<br><br><span class="hljs-keyword">import</span> com.sincland.insurance.partner.exception.BusinessException;<br><span class="hljs-keyword">import</span> com.sincland.insurance.partner.pojo.other.ApiResult;<br><span class="hljs-keyword">import</span> org.apache.commons.lang3.ObjectUtils;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.http.converter.HttpMessageNotReadableException;<br><span class="hljs-keyword">import</span> org.springframework.validation.BindingResult;<br><span class="hljs-keyword">import</span> org.springframework.validation.FieldError;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.MethodArgumentNotValidException;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 异常处理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionHandlerConfig</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-built_in">this</span>.getClass());<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理其他所有异常</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> req 请求参数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e   异常信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ApiResult</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ExceptionHandler(value = Exception.class)</span><br>    <span class="hljs-keyword">public</span> ApiResult&lt;?&gt; exceptionHandler(HttpServletRequest req, Exception e) &#123;<br>        String msg;<br>        <span class="hljs-keyword">if</span> (ObjectUtils.isNotEmpty(e.getCause())) &#123;<br>            msg = e.getCause().getMessage();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            msg = e.getMessage();<br>        &#125;<br>        log.error(<span class="hljs-string">&quot;接口:&#123;&#125; 发生运行时异常:&#123;&#125;&quot;</span>, req.getRequestURI(), msg);<br>        e.printStackTrace();<br>        <span class="hljs-keyword">return</span> ApiResult.exception(msg);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 校验参数异常</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> req HttpServletRequest</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e   异常信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ApiResult</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ExceptionHandler(value = MethodArgumentNotValidException.class)</span><br>    <span class="hljs-keyword">public</span> ApiResult&lt;?&gt; handleMethodArgumentNotValidException(HttpServletRequest req, MethodArgumentNotValidException e) &#123;<br>        <span class="hljs-type">BindingResult</span> <span class="hljs-variable">bindingResult</span> <span class="hljs-operator">=</span> e.getBindingResult();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;请求参数校验不通过: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (FieldError fieldError : bindingResult.getFieldErrors()) &#123;<br>            msg.append(fieldError.getField()).append(<span class="hljs-string">&quot;:&quot;</span>).append(fieldError.getDefaultMessage()).append(<span class="hljs-string">&quot;，&quot;</span>);<br>        &#125;<br>        msg.replace(msg.length() - <span class="hljs-number">1</span>, msg.length(), <span class="hljs-string">&quot;&quot;</span>);<br>        log.error(<span class="hljs-string">&quot;接口:&#123;&#125; &#123;&#125;&quot;</span>, req.getRequestURI(), msg);<br>        <span class="hljs-keyword">return</span> ApiResult.exception(msg.toString());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理业务异常</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> req 请求参数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e   异常信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ApiResult</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ExceptionHandler(value = BusinessException.class)</span><br>    <span class="hljs-keyword">public</span> ApiResult&lt;?&gt; businessExceptionHandler(HttpServletRequest req, BusinessException e) &#123;<br>        log.error(<span class="hljs-string">&quot;接口:&#123;&#125; 发生业务性异常:&#123;&#125;&quot;</span>, req.getRequestURI(), e.getMessage());<br>        <span class="hljs-keyword">return</span> e.getApiResultIsException() ? ApiResult.exception(e.getStatus(), e.getMessage())<br>                : ApiResult.fail(e.getStatus(), e.getMessage());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理空指针异常</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> req 请求参数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e   异常信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ApiResult</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ExceptionHandler(value = NullPointerException.class)</span><br>    <span class="hljs-keyword">public</span> ApiResult&lt;?&gt; nullPointerExceptionHandler(HttpServletRequest req, NullPointerException e) &#123;<br>        log.error(<span class="hljs-string">&quot;接口:&#123;&#125; 发生空指针异常:&#123;&#125;&quot;</span>, req.getRequestURI(), e.getStackTrace()[<span class="hljs-number">0</span>]);<br>        e.printStackTrace();<br>        <span class="hljs-keyword">return</span> ApiResult.exception(<span class="hljs-string">&quot;发生空指针异常:&quot;</span> + e.getStackTrace()[<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 请求消息无法解析异常</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> req 请求参数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e   异常信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ApiResult</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ExceptionHandler(value = HttpMessageNotReadableException.class)</span><br>    <span class="hljs-keyword">public</span> ApiResult&lt;?&gt; httpMessageNotReadableExceptionHandler(HttpServletRequest req, HttpMessageNotReadableException e) &#123;<br>        log.error(<span class="hljs-string">&quot;接口:&#123;&#125; 请求消息无法解析异常:&#123;&#125;&quot;</span>, req.getRequestURI(), e.getMessage());<br>        e.printStackTrace();<br>        <span class="hljs-keyword">return</span> ApiResult.fail(<span class="hljs-string">&quot;请检查请求体格式&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以通过<code>@ExceptionHandler</code>指定各式各样的异常处理，包括自定义的异常、Java 内置的异常、校验参数异常<code>MethodArgumentNotValidException</code>。通过与<code>ApiResult</code>联动，达到即使程序异常，也会按照正常的数据格式进行响应。</p>
<p>也可以实现在服务层需要返回一些业务性错误，但你的方法返回值却不是<code>ApiResult</code>，那么你可以抛出一些自定义异常，再在<code>ExceptionHandlerConfig</code>中进行处理。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 实现指定概率的抽奖</title>
    <url>/2022/12/16/Java/Scene/Lottery/</url>
    <content><![CDATA[<p>一提到抽奖，很多人就会联想到<code>随机数</code>这个东西。是的没错，那么怎么样既能实现随机的抽奖，又可以人为的控制每个奖品的概率呢？往下看。</p>
<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>Tip：在实际的业务场景中，对于奖品概率的配置往往不是直接输入对应的百分比，而是<code>权重</code>，该值的取值范围大于等于0即可，那么对应的<code>奖品概率=奖品权重/所有奖品权重合计</code>。这样做的目的，是在配置时不需要输入通过人工精确分配的概率百分比，同时也可以规避总概率不等于100%的人为问题。</p>
<p>解决思路的灵感来源于<code>扇形统计图</code>和<code>转盘抽奖</code>，某一项占比越大，那么在圆形上占用的面积越多，在旋转后被抽中的概率也就越大。我们可以把圆形展开，变成一条线段或者一个矩形，<code>根据奖品各自的概率（权重）分配其所占用的面积</code>。假设我们的手指就是<code>转盘抽奖上的指针</code>，此时，手指随机落在某个奖品区间内的概率与他的区间大小是息息相关的。</p>
<p><img    class="lazyload" data-original="https://s2.loli.net/2022/12/18/vizhKSZNByxt4QF.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">思路示意图</span></p>
<p>上图中，我们暂且称<code>0,20,60,110,125</code>为节点，那么节点<code>0-20</code>为奖品1所在区域，<code>20-60</code>为奖品2所在区域，<code>60-110</code>为奖品3所在区域，<code>110-125</code>为奖品4所在区域。此时，生成一个0-125的随机数x，那么x的值在哪个奖品的区间内，抽中的就是哪个奖品。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="创建奖品对象"><a href="#创建奖品对象" class="headerlink" title="创建奖品对象"></a>创建奖品对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zyan.local.pojo.entity;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.math.BigDecimal;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> zyan</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2022/12/16 16:49 星期五</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Prize</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Prize</span><span class="hljs-params">(Integer id, String name, Integer weight)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.weight = weight;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer id;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 权重</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer weight;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="核心抽奖方法"><a href="#核心抽奖方法" class="headerlink" title="核心抽奖方法"></a>核心抽奖方法</h2><p>Tip：<code>RandomUtil</code>来自<code>hutool</code>第三方库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Prize <span class="hljs-title function_">lottery</span><span class="hljs-params">(List&lt;Prize&gt; prizeList)</span> &#123;<br>    <span class="hljs-comment">//按照权重从小到大排序奖品</span><br>    prizeList.sort(Comparator.comparingInt(Prize::getWeight));<br><br>    <span class="hljs-comment">//计算节点 节点的数量比奖品的数量多一个，即0</span><br>    List&lt;Integer&gt; nodeList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">//第一个节点为0</span><br>    nodeList.add(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (Prize prize : prizeList) &#123;<br>        <span class="hljs-comment">//每一个节点等于前一个节点+当前奖品的权重</span><br>        nodeList.add(nodeList.get(nodeList.size() - <span class="hljs-number">1</span>) + prize.getWeight());<br>    &#125;<br><br>    <span class="hljs-comment">//生成 0-结束节点 的随机数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">randomInt</span> <span class="hljs-operator">=</span> RandomUtil.randomInt(<span class="hljs-number">0</span>, nodeList.get(nodeList.size() - <span class="hljs-number">1</span>));<br><br>    <span class="hljs-comment">//最终抽奖逻辑 此处需要从第二个节点开始遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nodeList.size(); i++) &#123;<br>        <span class="hljs-comment">//本次节点</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">endNode</span> <span class="hljs-operator">=</span> nodeList.get(i);<br>        <span class="hljs-comment">//前一个节点</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">startNode</span> <span class="hljs-operator">=</span> nodeList.get(i - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//若随机数大于等于前一个节点并且小于本节点，在prizeList中位于i-1位置的奖品为抽中奖品</span><br>        <span class="hljs-comment">//Tip：比较大小时，左闭右开与左开右闭都可以，不影响整体概率</span><br>        <span class="hljs-keyword">if</span> (randomInt &gt;= startNode<br>                &amp;&amp; randomInt &lt; endNode) &#123;<br>            <span class="hljs-keyword">return</span> prizeList.get(i - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;程序异常 生成的随机数不在任何奖品区间内&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="创建模拟数据并验证概率"><a href="#创建模拟数据并验证概率" class="headerlink" title="创建模拟数据并验证概率"></a>创建模拟数据并验证概率</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Prize&gt; prizeList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    prizeList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Prize</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;奖品0&quot;</span>, <span class="hljs-number">2300</span>));<br>    prizeList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Prize</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;奖品1&quot;</span>, <span class="hljs-number">200</span>));<br>    prizeList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Prize</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;奖品2&quot;</span>, <span class="hljs-number">500</span>));<br>    prizeList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Prize</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;奖品3&quot;</span>, <span class="hljs-number">800</span>));<br>    prizeList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Prize</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;奖品4&quot;</span>, <span class="hljs-number">800</span>));<br><br><br>    <span class="hljs-comment">//进行一千次抽奖验证概率</span><br>    List&lt;Prize&gt; lotteryResult = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">1000</span>; i++) &#123;<br>        lotteryResult.add(lottery(prizeList));<br>    &#125;<br>    Map&lt;String, List&lt;Prize&gt;&gt; collect = lotteryResult.stream().collect(Collectors.groupingBy(Prize::getName));<br>    collect.forEach((k, v) -&gt; System.out.println(k + <span class="hljs-string">&quot; 被抽中 &quot;</span> + v.size() + <span class="hljs-string">&quot; 次&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>打印输出</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><code class="hljs tap">奖品4 被抽中<span class="hljs-number"> 183 </span>次<br>奖品3 被抽中<span class="hljs-number"> 159 </span>次<br>奖品0 被抽中<span class="hljs-number"> 514 </span>次<br>奖品2 被抽中<span class="hljs-number"> 113 </span>次<br>奖品1 被抽中<span class="hljs-number"> 32 </span>次<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java业务场景应用</tag>
      </tags>
  </entry>
</search>
